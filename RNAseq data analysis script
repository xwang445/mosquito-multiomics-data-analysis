# RNAseq data fastq files quality check
#!/bin/bash
  
#SBATCH --nodes=1
#SBATCH --ntasks=4
#SBATCH --cpus-per-task=1
#SBATCH --mem=128G
#SBATCH --time=48:00:00
#SBATCH --mail-user=email@address
#SBATCH --mail-type=ALL
#SBATCH -p intel
#SBATCH --output=RNA_QC_align_%j.log

module load fastqc/0.11.9

# Maximum number of parallel FastQC jobs
MAX_JOBS=4
CURRENT_JOBS=0

# Loop through each directory in soapnuke/clean/
for dir in RNAseq/soapnuke/clean/{1..24}; do
    # Check if the directory exists
    if [ -d "$dir" ]; then
        # Perform FastQC on each .fq.gz file in the directory in parallel
        for file in "${dir}"/*.fq.gz; do
            fastqc -o RNAseq/fastqc "$file" &
            let CURRENT_JOBS=CURRENT_JOBS+1
    
            # Wait if the number of current jobs reaches the maximum
            if [ "$CURRENT_JOBS" -ge "$MAX_JOBS" ]; then
                wait -n
                let CURRENT_JOBS=CURRENT_JOBS-1
            fi
        done
    else
        echo "Directory $dir not found."
    fi
done

# Wait for all background jobs to finish
wait

# alignment with STAR

#!/bin/bash

#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=8
#SBATCH --mem=128G
#SBATCH --time=60:00:00
#SBATCH --mail-user=email@address
#SBATCH --mail-type=ALL
#SBATCH --job-name="STAR_align"
#SBATCH -p intel
#SBATCH --output=star_%j.log

module load star/2.7.11a
module load samtools/1.17

# Define the reference genome and output directory
REFERENCE="Aaegy_genome/VectorBase-66_AaegyptiLVP_AGWG_Genome.fasta"
OUTPUT_DIR="RNAseq/bamfiles"

# Index reference genome
STAR --runThreadN 4 \
       --runMode genomeGenerate \
       --genomeDir Aaegy_genome \
       --genomeFastaFiles $REFERENCE \
       --sjdbGTFfile Aaegy_genome/VectorBase-66_AaegyptiLVP_AGWG.gff

# Maximum number of parallel star jobs
MAX_JOBS=8
CURRENT_JOBS=0

# Path to the STAR genome index directory
GENOME_DIR="Aaegy_genome"

# Directory containing the 36 subdirectories
PARENT_DIR="soapnuke/clean"

# Loop through each directory and process the files
for i in $(seq 1 24); do
    # Define input files
    FILE1="${PARENT_DIR}/${i}/${i}_1.fq.gz"
    FILE2="${PARENT_DIR}/${i}/${i}_2.fq.gz"

    # Check if both files exist
    if [[ -f "$FILE1" && -f "$FILE2" ]]; then
        # Define output directory for this pair
        OUT_DIR="${OUTPUT_DIR}/${i}"
        mkdir -p "$OUT_DIR"
        # Run STAR alignment
        STAR --genomeDir "$GENOME_DIR" \
              --readFilesIn "$FILE1" "$FILE2" \
              --runThreadN 8 \
              --outFileNamePrefix "$OUT_DIR/" \
              --outSAMtype BAM SortedByCoordinate \
              --readFilesCommand zcat

        echo "Alignment done for pair ${i}"
    else
        echo "Files for pair ${i} not found."
    fi
done

# Count reads for genes by htseq
module load samtools/1.17

# Path to the reference gene model file (like a .bed file)
REF_GTF_FILE="Aaegy_genome/VectorBase-66_AaegyptiLVP_AGWG.gff"

# Base directory containing the numbered subdirectories 
BASE_DIR="RNAseq/bamfiles"

# Output directories for results
OUTPUT_DIR="RNAseq/HTseq/output"

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Maximum number of parallel jobs
MAX_JOBS=24

# Loop through each subdirectory and run RSeQC tools
for i in {1..24}; do
    BAM_FILE="${BASE_DIR}/${i}/Aligned.sortedByCoord.out.bam"

    if [ -f "$BAM_FILE" ]; then

        # Index the BAM file with samtools
        samtools index "$BAM_FILE"
    
        # Define output file names
        OUT_count_mat="${OUTPUT_DIR}/${i}_counts.txt"

        # Run htseq-count
        htseq-count -f bam -s no -t exon -i gene_id "$BAM_FILE" "$REF_GTF_FILE" > "$OUT_count_mat" &
    
        # Limit number of parallel jobs
        if (( $(jobs -r | wc -l) >= MAX_JOBS )); then
                wait -n
        fi

        echo "Completed analysis for directory ${i}"
    else
        echo "BAM file not found in ${BASE_DIR}/${i}"
    fi
done

# Wait for all background jobs to finish
wait

echo "All analyses are completed."

# DESeq2 for DEGs analysis and making plots in R
rm(list = ls())

library(DESeq2)
library(ggplot2)
library(pheatmap)
library(tibble)
library(dplyr)
library(ggpubr)
library(ggrepel)

work_dir <- "RNAseq/DESeq2_results3"
if (!file.exists(work_dir)) {dir.create(work_dir, recursive = TRUE)}
setwd(work_dir)

directory <- "RNAseq/htseq_results"

# in the MA plot, label out the NK2 AAEL003794, KAT8 AAEL007672, PP6 AAEL026630, RMT1 AAEL001037

# Loop for groups 1-6 (PE72), 7-12 (PBM24), 13-18 (PBM60), 19-24 (PBM36)
for(i in seq(1, 24, by = 6)) {

  if (i == 1) {
    plot_title <- "PE72 WT vs KO"
  } else if (i == 7) {
    plot_title <- "PBM24 WT vs KO"
  } else if (i == 13) {
    plot_title <- "PBM60 WT vs KO"
  } else if (i == 19) {
    plot_title <- "PBM36 WT vs KO"
  } else {
    plot_title <- "error: not correct number ID"
  }
  
  group_files <- paste0(seq(i, i+5), "_counts.txt") %>% as.factor()
  group_conditions <- c(rep("WT", 3), rep("KO", 3)) %>% as.factor()
  
  # Create a data frame for one group
  group_sample_table <- data.frame(sampleName = group_files,
                                   fileName = group_files,
                                   condition = group_conditions)
  
  group_sample_table$condition <- factor(group_sample_table$condition, levels = c("WT","KO"))
  
  # DESeq2 analysis
  ddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = group_sample_table,
                                         directory = directory,
                                         design= ~ condition)
  
  dds <- DESeq(ddsHTSeq)
  
  #Note on factor levels
  dds$condition <- relevel(dds$condition, ref = "WT")
  
  #Differential expression analysis
  res <- results(dds)
  
  #Log fold change shrinkage for visualization and ranking
  resLFC <- lfcShrink(dds, coef="condition_KO_vs_WT", type="apeglm")
  # Exclude NAs and filter by padj
  resLFC <- resLFC[!is.na(resLFC$padj),]
  
  # PCA Plot Preparation vst: Variance Stabilizing Transformation
  vsd_group <- vst(dds, blind = FALSE)
  pca_plot <- plotPCA(vsd_group, intgroup = "condition", returnData = F) +
    scale_y_continuous(limits = c(-5, 5))

  # Set the filename for the PCA plot
  pca_plot_filename <- paste0("PCA_plot_sample_", plot_title, ".png")
  
  # Open a new png device to save the plot
  png(file = pca_plot_filename, width = 1600, height = 1200, res = 300)
  plot(pca_plot)
  dev.off()

  print("Plot generation completed.")
  print(paste0("Saved PCA plot to", pca_plot_filename))
  
  topVarGenes <- head(order(rowVars(assay(vsd_group)), decreasing = TRUE), 20)
  mat  <- assay(vsd_group)[ topVarGenes, ]
  mat  <- mat - rowMeans(mat)
  anno <- as.data.frame(colData(vsd_group)[, c("condition", "sizeFactor")]) # The sizeFactor is 
  
  heatmap_plot <- pheatmap(mat, annotation_col = anno, show_colnames = F)
  
  # Set the filename for the heatmap plot
  heatmap_plot_filename <- paste0("Heatmap_plot_sample_", plot_title, ".png")
  
  # Open a new png device to save the plot
  png(file = heatmap_plot_filename, width = 1600, height = 1600, res = 300)
  print(heatmap_plot)
  dev.off()
  
  res <- as.data.frame(res)
  res_filtered <- res %>% filter(!is.na(padj))
  
  # Define a named vector with custom gene labels
  myGenes <- c(AAEL003794 = "NK2", 
               AAEL007672 = "KAT8", 
               AAEL026630 = "PP6", 
               AAEL001037 = "RMT1")
  # Check if rownames are set properly; if not, set them (this step assumes gene IDs are in a column)
  if (is.null(rownames(res_filtered))) {
    res_filtered$gene_id <- as.character(res_filtered$gene_id)  # Ensure gene IDs are characters, not factors
    rownames(res_filtered) <- res_filtered$gene_id}
  
  # Update gene names in the dataset for the plot
  # This step maps gene IDs to custom names only for those specified in 'myGenes'
  res_filtered$display_name <- ifelse(rownames(res_filtered) %in% names(myGenes), myGenes[rownames(res_filtered)], NA)
  
  # ggmaplot with updated labels with padj < 0.05
  ma_plot <- ggmaplot(res_filtered, main = plot_title,
           fdr = 0.05, fc = 2, size = 1,
           palette = c("#B31B21", "#1465AC", "darkgray"),
           #genenames = as.vector(res_filtered$display_name),
           legend = "right",
           font.legend = c("bold", 14),
           font.main = c("bold", 18),
           top = 0,
           ggtheme = ggplot2::theme_minimal() +
             ggplot2::theme(axis.title.x = element_text(size = 16, face = "bold"),
                            axis.title.y = element_text(size = 16, face = "bold"),
                            axis.text.x = element_text(size = 14, face = "bold"),
                            axis.text.y = element_text(size = 14, face = "bold")))
  
  # Adding geom_text_repel from ggrepel package for labeling points
  ma_plot <- ma_plot +
    geom_label_repel(size = 6, # adjust the label font size
                     fontface="bold",
                     data = res_filtered, # Applying label filtering here
                     aes(label = as.vector(res_filtered$display_name),
                         x = log2(baseMean), y = log2FoldChange),
                     min.segment.length = 0,
                     segment.color = 'red')
  # Customize the y-axis
  #ma_plot <- ma_plot + scale_y_continuous(limits = c(-5, 5), 
  #                                       breaks = seq(-5, 5, by = 1))
  
  # Set the filename for the MA plot
  ma_plot_filename <- paste0("MA_plot_sample_", plot_title, ".png")
  
  # Open a new png device to save the MA plot
  png(file = ma_plot_filename, width = 2700, height = 1800, res = 300)
  
  print(ma_plot)
  dev.off()
  
  # Add protein description to res_filtered table
  GeneAddProtein_df <- 
    read.delim("/Users/kevinwang0724/Desktop/Mosquito/Yike/iEcR_RNAseq/GeneAddProtein.txt", sep = "\t")
  GeneAddProtein_df <- GeneAddProtein_df[,c(1,2,3)]
  
  res_filtered$GeneID <- rownames(res_filtered)
  res_filtered_addpro_df <- merge(GeneAddProtein_df, res_filtered, by = "GeneID", all.x = TRUE)
  res_filtered_addpro_df <- res_filtered_addpro_df %>% filter(!is.na((padj)), padj < 0.05)
  res_filtered_addpro_dfname <- paste0("DESeq2_res_", plot_title, ".csv")
  
  write.csv(res_filtered_addpro_df, file = res_filtered_addpro_dfname, row.names = F)
}

# DEGs clustering and making plots in R
rm(list=ls())

library(DESeq2)
library(ggplot2)
library(dplyr)
library(pheatmap)
library(readxl)
library(ComplexHeatmap)
library(gridExtra)
library(forcats)
library(grid)
library(reshape2)
library(umap)

# Specify the directory path
dir_path <- "RNAseq/genes_clutering"

# Check if the directory exists, and create it if it doesn't
if (!dir.exists(dir_path)) {
  dir.create(dir_path, recursive = TRUE)
}
setwd(dir_path)
directory <- "RNAseq/htseq_results"

# Define group files and factors
group_files <- paste0(c(1,2,3,4,5,6,
                        7,8,9,10,11,12,
                        19,20,21,22,23,24,
                        13,14,15,16,17,18), "_counts.txt") %>% as.factor()

strain <- factor(c(rep("wt", 3), rep("FoxA_KO", 3),
                   rep("wt", 3), rep("FoxA_KO", 3),
                   rep("wt", 3), rep("FoxA_KO", 3),
                   rep("wt", 3), rep("FoxA_KO", 3)))

hour <- factor(c(rep("PE72", 3), rep("PE72", 3),
                 rep("PBM24", 3), rep("PBM24", 3),
                 rep("PBM36", 3), rep("PBM36", 3),
                 rep("PBM60", 3), rep("PBM60", 3)))

replicate <- factor(c(1,2,3,1,2,3,
                      1,2,3,1,2,3,
                      1,2,3,1,2,3,
                      1,2,3,1,2,3))

# Create a data frame for one group
group_sample_table <- data.frame(sampleName = group_files,
                                 fileName = group_files,
                                 strain = strain,
                                 hour = hour,
                                 replicate = replicate)

# DESeq2 analysis
ddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = group_sample_table,
                                       directory = directory,
                                       design= ~ strain + hour)

ddsHTSeq$hour <- relevel(ddsHTSeq$hour, ref = "PE72")
ddsHTSeq <- DESeq(ddsHTSeq, test = "LRT", reduced = ~ hour)
res <- results(ddsHTSeq)

# Normalize counts
normalized_counts <- counts(ddsHTSeq, normalized = TRUE)

# Average the groups as previously done
group_sizes <- c(3, 3, 3, 3, 3, 3, 3, 3)
averages <- list()
current_col <- 1

for(size in group_sizes) {
  group_average <- rowMeans(normalized_counts[, current_col:(current_col + size - 1)], na.rm = TRUE)
  averages[[paste("Group", current_col, "-", current_col + size - 1)]] <- group_average
  current_col <- current_col + size
}

average_matrix <- do.call(cbind, averages)

# Scaling the rows
cal_z_score <- function(x){
  s <- sd(x, na.rm = TRUE)
  if(s == 0) rep(0, length(x)) else (x - mean(x, na.rm = TRUE)) / s
}

mt_norm <- t(apply(average_matrix, 1, cal_z_score))

# Use the differentially expressed (adjusted P < 0.05) across the 4 conditions by ANOVA
# intersect the 4 groups DEGs, WT VS KO for the four time points PE72, PBM24, PBM36, PBM60.
PBM24_DEGs_list <- read.csv("RNAseq/Deseq2_results2/DESeq2_res_PBM24 WT vs KO.csv")
PBM36_DEGs_list <- read.csv("RNAseq/Deseq2_results2/DESeq2_res_PBM36 WT vs KO.csv")
PBM60_DEGs_list <- read.csv("RNAseq/Deseq2_results2/DESeq2_res_PBM60 WT vs KO.csv")
PE72_DEGs_list <- read.csv("RNAseq/Deseq2_results2/DESeq2_res_PE72 WT vs KO.csv")

# Extract the first column
PBM24_genes <- unique(PBM24_DEGs_list[[1]])
PBM36_genes <- unique(PBM36_DEGs_list[[1]])
PBM60_genes <- unique(PBM60_DEGs_list[[1]])
PE72_genes <- unique(PE72_DEGs_list[[1]])

# Combine all gene lists into a single list
all_genes <- list(PBM24_genes, PBM36_genes, PBM60_genes, PE72_genes)

# Create a table that counts the occurrence of each gene across all lists
gene_count <- table(unlist(all_genes))

# Select genes that appear in at least three of the four lists
common_genes <- names(gene_count[gene_count >= 3])

# Print the number of common genes and the list of common genes
cat("Number of common genes:", length(common_genes), "\n")
print(common_genes)

mt_heatmap <- mt_norm[rownames(mt_norm) %in% common_genes, ]
colnames(mt_heatmap) <- c("PE72_wt", "PE72_FoxA_KO",
                          "PBM24_wt", "PBM24_FoxA_KO",
                          "PBM36_wt", "PBM36_FoxA_KO",
                          "PBM60_wt", "PBM60_FoxA_KO")

mt_heatmap_wt <- mt_heatmap[, c("PE72_wt", "PBM24_wt", "PBM36_wt", "PBM60_wt")]
mt_heatmap_ko <- mt_heatmap[, c("PE72_FoxA_KO", "PBM24_FoxA_KO", "PBM36_FoxA_KO", "PBM60_FoxA_KO")]

interested_genes <- c("AAEL003794", "AAEL026630")

# get the row index
# Get the indices of rows matching the interested genes
row_indices <- which(rownames(mt_heatmap) %in% interested_genes)
row_indices
# Create a row annotation object
row_anno <- rowAnnotation(foo = anno_mark(at = row_indices, 
                                          labels = interested_genes),
                          annotation_name_gp= gpar(fontsize = 20))

# Plot the heatmap with the filtered and normalized data
heatmap_plot <- Heatmap(mt_heatmap_wt,
                        name = "Global Heatmap",
                        cluster_rows = TRUE,
                        split = 10,
                        cluster_columns = FALSE,
                        column_labels = colnames(mt_heatmap_wt),
                        show_row_names = FALSE,
                        column_names_rot = 45,
                        right_annotation = row_anno)

plot_filename <- paste0("wt_heatmap.png")
png(file = plot_filename, width = 2000, height = 4000, res = 300)
print(heatmap_plot)
dev.off()

# PCA
# Read data
data <- mt_heatmap

# Perform PCA
pca_results <- prcomp(data, scale. = TRUE)

# Get the variance explained by each principal component
variance_explained <- pca_results$sdev^2 / sum(pca_results$sdev^2)
percentage_explained <- variance_explained * 100

# Extract the scores
scores <- as.data.frame(pca_results$x)

# Create a dataframe for plotting
plot_data <- data.frame(PC1 = scores[,1], PC2 = scores[,2])

# Generate the PCA plot
pca_plot <- ggplot(plot_data, aes(x = PC1, y = PC2)) +
  geom_point(alpha = 0.4, color = "blue") +  # Adjust color and transparency as needed
  theme_minimal() +
  labs(title = sprintf("PCA of Gene Expression Data (PC1: %.2f%%, PC2: %.2f%%)",
                       percentage_explained[1], percentage_explained[2]),
       x = sprintf("Principal Component 1 (%.2f%%)", percentage_explained[1]),
       y = sprintf("Principal Component 2 (%.2f%%)", percentage_explained[2]))

# Print the plot
print(pca_plot)

# Save the plot as a PNG file
ggsave("pca_plot.png", pca_plot, width = 10, height = 8, dpi = 300)

# UMAP 
# Assuming 'mt_heatmap' is already loaded in your R session
umap_results <- umap::umap(mt_heatmap)

# Extract the UMAP coordinates
umap_data <- as.data.frame(umap_results$layout)

# Add row names as a column for labeling or identification
umap_data$Gene = row.names(umap_data)

# Create a UMAP plot
umap_plot <- ggplot(umap_data, aes(x = V1, y = V2, label = Gene)) +
  geom_point(alpha = 0.6, color = "blue") +  # Adjust color and transparency as needed
  theme_minimal() +
  labs(title = "UMAP Projection of Gene Expression Data",
       x = "UMAP Dimension 1",
       y = "UMAP Dimension 2")

# Print the plot
print(umap_plot)

# Optionally save the plot
ggsave("umap_plot.png", umap_plot, width = 10, height = 8, dpi = 300)


# Plot the heatmap with the filtered and normalized data
heatmap_plot <- Heatmap(mt_heatmap_ko,
                        name = "Global Heatmap",
                        cluster_rows = TRUE,
                        split = 10,
                        cluster_columns = FALSE,
                        column_labels = colnames(mt_heatmap_ko),
                        show_row_names = FALSE,
                        column_names_rot = 45,
                        right_annotation = row_anno)

plot_filename <- paste0("ko_heatmap.png")
png(file = plot_filename, width = 2000, height = 4000, res = 300)
print(heatmap_plot)
dev.off()

row_anno <- rowAnnotation(foo = anno_mark(at = row_indices, 
                                          labels = interested_genes,
                                          labels_gp = gpar(fontsize = 20)))
# Plot the heatmap with the filtered and normalized data
heatmap_plot <- Heatmap(mt_heatmap,
                        name = "Z-score",
                        cluster_rows = TRUE,
                        split = 10,
                        cluster_columns = FALSE,
                        column_labels = colnames(mt_heatmap),
                        show_row_names = FALSE,
                        column_names_rot = 45,
                        right_annotation = row_anno,
                        row_names_gp = gpar(fontsize = 20),  # Increase row names text size
                        column_names_gp = gpar(fontsize = 20),  # Increase column names text size
                        heatmap_legend_param = list(legend_direction = "horizontal", 
                                                    labels_gp = gpar(fontsize = 15)  # Increase legend labels text size
                        ))

plot_filename <- paste0("all_heatmap.pdf")
pdf(file = plot_filename, width = 8, height = 10)
draw(heatmap_plot,
     heatmap_legend_side = "bottom")
dev.off()


library(ComplexHeatmap)
library(grid)

# Lists of transcription activation and repression genes with their names
interested_genes <- c("AAEL007672", "AAEL001037", "AAEL026630", "AAEL003794")
interested_names <- c("KAT8", "RMT1", "PP6", "NK2")

# Get indices of these genes in the heatmap matrix
all_row_indices <- which(rownames(mt_heatmap) %in% interested_genes)

# Filter the genes and names to include only those present in the heatmap
present_genes <- rownames(mt_heatmap)[all_row_indices]
present_labels <- interested_names[match(present_genes, interested_genes)]

# Concatenate gene IDs with names
present_labels <- paste(present_genes, present_labels)

# Create row annotation object with geneID and gene name
row_anno <- rowAnnotation(foo = anno_mark(at = all_row_indices, 
                                          labels = present_labels,
                                          labels_gp = gpar(fontsize = 20)),
                          annotation_name_gp = gpar(fontsize = 20))

# Plot the heatmap with the filtered and normalized data
heatmap_plot <- Heatmap(mt_heatmap,
                        name = "Z-score",
                        cluster_rows = TRUE,
                        split = 7,
                        cluster_columns = FALSE,
                        column_labels = colnames(mt_heatmap),
                        show_row_names = FALSE,
                        column_names_rot = 45,
                        right_annotation = row_anno,
                        row_names_gp = gpar(fontsize = 20),  # Increase row names text size
                        column_names_gp = gpar(fontsize = 20),  # Increase column names text size
                        heatmap_legend_param = list(legend_direction = "horizontal", 
                                                    labels_gp = gpar(fontsize = 15)  # Increase legend labels text size
                        ))

plot_filename <- paste0("all_heatmap.pdf")
pdf(file = plot_filename, width = 8, height = 10)
draw(heatmap_plot,
     heatmap_legend_side = "bottom")
dev.off()


# Check which repression genes are present in the rownames of mt_heatmap
present_repression_genes <- repression_genes[repression_genes %in% rownames(mt_heatmap)]

# Print the results
print(present_repression_genes)

cluster_ids <- row_order(heatmap_plot)

for (i in seq_along(cluster_ids)) {
  # Extract the gene IDs for the current cluster
  gene_ids <- rownames(mt_heatmap)[cluster_ids[[i]]]
  
  # Create a filename for the cluster
  filename <- paste0("cluster_", i, "_genes.csv")
  
  # Save the gene IDs to a CSV file without the first row as "x"
  write.table(gene_ids, file = filename, row.names = FALSE, col.names = FALSE,
              quote = FALSE, sep = ",")
}



# TO DO
# 1. separate the wt and KO to two clustering plots
# 2. use all DEGs to make the clustering plots.
# 3. for each clustering set, do the GO enrichemnt, and the boxplot
# of average genes expression level.
# 4. label the important genes in the corresponding clustering set.
# 5. Use clusterProfiler to add GO enrichment results to the heatmap.

# GO enrichment
# Install and load the necessary packages if you haven't already
library(wordcloud)
library(RColorBrewer)

# Assuming go_list is already loaded with 7 GO enrichment results

# Define the cluster sizes as per the given ratios
cluster_sizes <- c(530, 692, 805, 511, 417, 585, 732)

# Loop through each GO enrichment result, create a word cloud, and save as a PDF
for (i in seq_along(go_list)) {
  # Extract GO terms and calculate their weights
  go_terms <- go_list[[i]]$Name
  go_weights <- -log10(go_list[[i]]$P.value)
  
  # Define the filename for the PDF
  png_filename <- paste0("word_cloud_cluster_", i, ".png")
  par(mar = c(0, 0, 0, 0))
  # Open the PDF device
  png(file = png_filename, width = 20, height = 15, units = "in", res = 300)
  
  # Generate the word cloud
  set.seed(123)  # For reproducibility
  wordcloud(
    words = go_terms,          # The GO term names
    freq = go_weights,         # The weights (importance) of the terms
    min.freq = 3,              # Minimum frequency for a term to be included
    max.words = 6,           # Maximum number of words in the cloud
    random.order = TRUE,      # Place the most frequent words at the center
    rot.per = 0,            # Percentage of words with 90-degree rotation
    colors = brewer.pal(8, "Dark2")  # Color palette for the words
  )
  
  # Close the PDF device
  dev.off()
}

# Methods
# Upload gene list such as Down_18PBM.txt to the website VectorBase 
# Then perform the GO enrichment with online tools.
# Download the BP, CC, MF three results and save them as, for example,
# BP_18PBM_UP.tsv, CC_18PBM_UP.tsv, MF_18PBM_UP.tsv, 
# BP_18PBM_DOWN.tsv, CC_18PBM_DOWN.tsv, MF_18PBM_DOWN.tsv
# For 18PBM MF UP first
# red uses #ECA8A9, blue uses #74AED4
# Make the 96h plots first

bp_data <- read.delim("cluster6_bp.tsv", sep = "\t") %>% 
  filter(P.value < 0.05, Benjamini < 0.05, Bonferroni < 0.05) %>% mutate(class = "BP")
cc_data <- read.delim("cluster6_cc.tsv", sep = "\t") %>% 
  filter(P.value < 0.05, Benjamini < 0.05, Bonferroni < 0.05) %>% mutate(class = "CC")
mf_data <- read.delim("cluster6_mf.tsv", sep = "\t") %>% 
  filter(P.value < 0.05, Benjamini < 0.05, Bonferroni < 0.05) %>% mutate(class = "MF")
    
combined_data <- bind_rows(bp_data, cc_data, mf_data)
    
# Order the data by class and then by Result.count within each class
combined_data <- combined_data %>%
      group_by(class) %>%
      top_n(7, Result.count) %>%
      ungroup() %>%
      arrange(class, desc(Result.count)) %>%
      mutate(Name = factor(Name, levels = unique(Name)))
    
# Set the space between the bar number label and the border automatically
# Automatically adjust space based on the maximum value
max_value <- max(combined_data$Result.count)
space_needed <- max_value * 0.1
    
    # Now plot using the adjusted combined_data
GO_plot <- ggplot(combined_data, aes(x = Name, y = Result.count, fill = class)) +
    geom_bar(stat = "identity") +
    coord_flip() + # Make it horizontal
    geom_text(aes(label = Result.count), hjust = -0.1, fontface = "bold") + # Adjust text position
    scale_fill_manual(values = c("BP" = "#F8766D", "CC" = "#00BA38", "MF" = "#619CFF"),
                      name = "GO class") +
    labs(x = "GO Term", y = "Gene Count", title = paste("Cluster 6 GO Enrichment", sep = " ")) +
    theme(
      panel.background = element_blank(), # Remove panel background
      panel.grid.major = element_line(colour = "lightgrey"), # Remove major grid lines
      panel.grid.minor = element_blank(), # Remove minor grid lines
      panel.border = element_rect(colour = "black", fill=NA, linewidth=1),
      axis.title.x = element_text(size = 16, color = "black", face = "bold"),
      axis.title.y = element_text(size = 16, color = "black",face = "bold"),
      axis.text.x = element_text(size = 16, color = "black",face = "bold"),
      axis.text.y = element_text(size = 16, color = "black",face = "bold"),
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5), # Make plot title bold and centered
      legend.title = element_text(face = "bold"), # Make legend title bold
      legend.text = element_text(face = "bold"),
      ) +
      scale_y_continuous(expand = expansion(add = c(0, space_needed)))
    
    # Set the filename for the plot
    GO_plot_filename <- c("GO_plot_cluster6.png")
    png(file = GO_plot_filename, width = 3300, height = 1600, res = 300)
    print(GO_plot)
    dev.off()
    
    # Make dot plot
    dot_plot <- ggplot(combined_data, aes(x = Pct.of.bgd, y = reorder(Name, Pct.of.bgd), 
                                          color = P.value, size = Result.count)) +
      geom_point() + # Use geom_point for dot plots, now with size aesthetic
      scale_color_gradient(low = "blue", high = "red") + # Color gradient for P.values
      labs(title = paste(plot_title, "Genes GO dotplot", sep = " "), x = "Percentage of Background", y = "", color = "P value", size = "Counts") +
      theme_minimal() +
      theme(legend.position = "right",
            panel.border = element_rect(colour = "black", fill=NA, linewidth=1),
            axis.title.x = element_text(size = 16, color = "black", face = "bold"),
            axis.title.y = element_text(size = 16, color = "black",face = "bold"),
            axis.text.x = element_text(size = 16, color = "black",face = "bold"),
            axis.text.y = element_text(size = 16, color = "black",face = "bold"),
            plot.title = element_text(size = 20, face = "bold", hjust = 0.5), # Make plot title bold and centered
            legend.title = element_text(face = "bold"), # Make legend title bold
            legend.text = element_text(face = "bold"))
    
    dot_plot_filename <- paste0("Dot_plot_", plot_title, ".png")
    png(file = dot_plot_filename, width = 2700, height = 1600, res = 300)
    print(dot_plot)
    dev.off()

